import { fromEquals } from './Eq';
import { identity } from './function';
import { isNone, isSome, none, some as optionSome } from './Option';
import { showString } from './Show';
import { pipeable } from './pipeable';
/**
 * @since 2.0.0
 */
export const URI = 'Record';
/**
 * @since 2.0.0
 */
export function getShow(S) {
    return {
        show: r => {
            const elements = collect((k, a) => `${showString.show(k)}: ${S.show(a)}`)(r).join(', ');
            return elements === '' ? '{}' : `{ ${elements} }`;
        }
    };
}
/**
 * Calculate the number of key/value pairs in a record
 *
 * @since 2.0.0
 */
export function size(r) {
    return Object.keys(r).length;
}
/**
 * Test whether a record is empty
 *
 * @since 2.0.0
 */
export function isEmpty(r) {
    return Object.keys(r).length === 0;
}
const unorderedKeys = (r) => Object.keys(r);
/**
 * @since 2.0.0
 */
export function keys(r) {
    return unorderedKeys(r).sort();
}
/**
 * Map a record into an array
 *
 * @example
 * import {collect} from 'fp-ts/lib/Record'
 *
 * const x: { a: string, b: boolean } = { a: 'foo', b: false }
 * assert.deepStrictEqual(
 *   collect((key, val) => ({key: key, value: val}))(x),
 *   [{key: 'a', value: 'foo'}, {key: 'b', value: false}]
 * )
 *
 * @since 2.0.0
 */
export function collect(f) {
    return r => {
        const out = [];
        for (const key of keys(r)) {
            out.push(f(key, r[key]));
        }
        return out;
    };
}
/**
 * @since 2.0.0
 */
export const toArray = collect((k, a) => [k, a]);
export function toUnfoldable(unfoldable) {
    return r => {
        const arr = toArray(r);
        const len = arr.length;
        return unfoldable.unfold(0, b => (b < len ? optionSome([arr[b], b + 1]) : none));
    };
}
export function insertAt(k, a) {
    return r => {
        if (r[k] === a) {
            return r;
        }
        const out = Object.assign({}, r);
        out[k] = a;
        return out;
    };
}
const _hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @since 2.0.0
 */
export function hasOwnProperty(k, r) {
    return _hasOwnProperty.call(r, k);
}
export function deleteAt(k) {
    return r => {
        if (!_hasOwnProperty.call(r, k)) {
            return r;
        }
        const out = Object.assign({}, r);
        delete out[k];
        return out;
    };
}
/**
 * @since 2.0.0
 */
export function updateAt(k, a) {
    return r => {
        if (!hasOwnProperty(k, r)) {
            return none;
        }
        if (r[k] === a) {
            return optionSome(r);
        }
        const out = Object.assign({}, r);
        out[k] = a;
        return optionSome(out);
    };
}
/**
 * @since 2.0.0
 */
export function modifyAt(k, f) {
    return r => {
        if (!hasOwnProperty(k, r)) {
            return none;
        }
        const out = Object.assign({}, r);
        out[k] = f(r[k]);
        return optionSome(out);
    };
}
export function pop(k) {
    const deleteAtk = deleteAt(k);
    return r => {
        const oa = lookup(k, r);
        return isNone(oa) ? none : optionSome([oa.value, deleteAtk(r)]);
    };
}
/**
 * Test whether one record contains all of the keys and values contained in another record
 *
 * @since 2.0.0
 */
export function isSubrecord(E) {
    return (x, y) => {
        for (const k in x) {
            if (!_hasOwnProperty.call(y, k) || !E.equals(x[k], y[k])) {
                return false;
            }
        }
        return true;
    };
}
export function getEq(E) {
    const isSubrecordE = isSubrecord(E);
    return fromEquals((x, y) => isSubrecordE(x, y) && isSubrecordE(y, x));
}
export function getMonoid(S) {
    return {
        concat: (x, y) => {
            if (x === empty) {
                return y;
            }
            if (y === empty) {
                return x;
            }
            const keys = Object.keys(y);
            const len = keys.length;
            if (len === 0) {
                return x;
            }
            const r = Object.assign({}, x);
            for (let i = 0; i < len; i++) {
                const k = keys[i];
                r[k] = _hasOwnProperty.call(x, k) ? S.concat(x[k], y[k]) : y[k];
            }
            return r;
        },
        empty
    };
}
/**
 * Lookup the value for a key in a record
 *
 * @since 2.0.0
 */
export function lookup(k, r) {
    return _hasOwnProperty.call(r, k) ? optionSome(r[k]) : none;
}
/**
 * @since 2.0.0
 */
export const empty = {};
export function mapWithIndex(f) {
    return fa => record.mapWithIndex(fa, f);
}
export function map(f) {
    return mapWithIndex((_, a) => f(a));
}
export function reduceWithIndex(b, f) {
    return fa => record.reduceWithIndex(fa, b, f);
}
export function foldMapWithIndex(M) {
    const foldMapWithIndexM = record.foldMapWithIndex(M);
    return f => fa => foldMapWithIndexM(fa, f);
}
export function reduceRightWithIndex(b, f) {
    return fa => record.reduceRightWithIndex(fa, b, f);
}
/**
 * Create a record with one key/value pair
 *
 * @since 2.0.0
 */
export function singleton(k, a) {
    return { [k]: a };
}
export function traverseWithIndex(F) {
    const traverseWithIndexF = record.traverseWithIndex(F);
    return f => ta => traverseWithIndexF(ta, f);
}
export function traverse(F) {
    const traverseWithIndexF = traverseWithIndex(F);
    return f => traverseWithIndexF((_, a) => f(a));
}
export function sequence(F) {
    return traverseWithIndex(F)((_, a) => a);
}
export function partitionMapWithIndex(f) {
    return fa => record.partitionMapWithIndex(fa, f);
}
export function partitionWithIndex(predicateWithIndex) {
    return fa => record.partitionWithIndex(fa, predicateWithIndex);
}
export function filterMapWithIndex(f) {
    return fa => record.filterMapWithIndex(fa, f);
}
export function filterWithIndex(predicateWithIndex) {
    return fa => record.filterWithIndex(fa, predicateWithIndex);
}
export function fromFoldable(M, F) {
    const fromFoldableMapM = fromFoldableMap(M, F);
    return fka => fromFoldableMapM(fka, identity);
}
export function fromFoldableMap(M, F) {
    return (ta, f) => {
        return F.reduce(ta, {}, (r, a) => {
            const [k, b] = f(a);
            r[k] = _hasOwnProperty.call(r, k) ? M.concat(r[k], b) : b;
            return r;
        });
    };
}
/**
 * @since 2.0.0
 */
export function every(predicate) {
    return r => {
        for (const k in r) {
            if (!predicate(r[k])) {
                return false;
            }
        }
        return true;
    };
}
/**
 * @since 2.0.0
 */
export function some(predicate) {
    return r => {
        for (const k in r) {
            if (predicate(r[k])) {
                return true;
            }
        }
        return false;
    };
}
/**
 * @since 2.0.0
 */
export function elem(E) {
    return (a, fa) => {
        for (const k in fa) {
            if (E.equals(fa[k], a)) {
                return true;
            }
        }
        return false;
    };
}
/**
 * @since 2.0.0
 */
export const record = {
    URI,
    map: (fa, f) => record.mapWithIndex(fa, (_, a) => f(a)),
    reduce: (fa, b, f) => record.reduceWithIndex(fa, b, (_, b, a) => f(b, a)),
    foldMap: M => {
        const foldMapWithIndexM = record.foldMapWithIndex(M);
        return (fa, f) => foldMapWithIndexM(fa, (_, a) => f(a));
    },
    reduceRight: (fa, b, f) => record.reduceRightWithIndex(fa, b, (_, a, b) => f(a, b)),
    traverse: (F) => {
        const traverseWithIndexF = record.traverseWithIndex(F);
        return (ta, f) => traverseWithIndexF(ta, (_, a) => f(a));
    },
    sequence,
    compact: (fa) => {
        const r = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            const optionA = fa[key];
            if (isSome(optionA)) {
                r[key] = optionA.value;
            }
        }
        return r;
    },
    separate: (fa) => {
        const left = {};
        const right = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            const e = fa[key];
            switch (e._tag) {
                case 'Left':
                    left[key] = e.left;
                    break;
                case 'Right':
                    right[key] = e.right;
                    break;
            }
        }
        return {
            left,
            right
        };
    },
    filter: (fa, predicate) => {
        return record.filterWithIndex(fa, (_, a) => predicate(a));
    },
    filterMap: (fa, f) => record.filterMapWithIndex(fa, (_, a) => f(a)),
    partition: (fa, predicate) => {
        return record.partitionWithIndex(fa, (_, a) => predicate(a));
    },
    partitionMap: (fa, f) => record.partitionMapWithIndex(fa, (_, a) => f(a)),
    wither: (F) => {
        const traverseF = record.traverse(F);
        return (wa, f) => F.map(traverseF(wa, f), record.compact);
    },
    wilt: (F) => {
        const traverseF = record.traverse(F);
        return (wa, f) => F.map(traverseF(wa, f), record.separate);
    },
    mapWithIndex: (fa, f) => {
        const out = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            out[key] = f(key, fa[key]);
        }
        return out;
    },
    reduceWithIndex: (fa, b, f) => {
        let out = b;
        const keys = Object.keys(fa).sort();
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            const k = keys[i];
            out = f(k, out, fa[k]);
        }
        return out;
    },
    foldMapWithIndex: M => (fa, f) => {
        let out = M.empty;
        const keys = Object.keys(fa).sort();
        const len = keys.length;
        for (let i = 0; i < len; i++) {
            const k = keys[i];
            out = M.concat(out, f(k, fa[k]));
        }
        return out;
    },
    reduceRightWithIndex: (fa, b, f) => {
        let out = b;
        const keys = Object.keys(fa).sort();
        const len = keys.length;
        for (let i = len - 1; i >= 0; i--) {
            const k = keys[i];
            out = f(k, fa[k], out);
        }
        return out;
    },
    traverseWithIndex: (F) => (ta, f) => {
        const keys = Object.keys(ta);
        if (keys.length === 0) {
            return F.of(empty);
        }
        let fr = F.of({});
        for (const key of keys) {
            fr = F.ap(F.map(fr, r => (b) => {
                r[key] = b;
                return r;
            }), f(key, ta[key]));
        }
        return fr;
    },
    partitionMapWithIndex: (fa, f) => {
        const left = {};
        const right = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            const e = f(key, fa[key]);
            switch (e._tag) {
                case 'Left':
                    left[key] = e.left;
                    break;
                case 'Right':
                    right[key] = e.right;
                    break;
            }
        }
        return {
            left,
            right
        };
    },
    partitionWithIndex: (fa, predicateWithIndex) => {
        const left = {};
        const right = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            const a = fa[key];
            if (predicateWithIndex(key, a)) {
                right[key] = a;
            }
            else {
                left[key] = a;
            }
        }
        return {
            left,
            right
        };
    },
    filterMapWithIndex: (fa, f) => {
        const r = {};
        const keys = Object.keys(fa);
        for (const key of keys) {
            const optionB = f(key, fa[key]);
            if (isSome(optionB)) {
                r[key] = optionB.value;
            }
        }
        return r;
    },
    filterWithIndex: (fa, predicateWithIndex) => {
        const out = {};
        let changed = false;
        for (const key in fa) {
            if (_hasOwnProperty.call(fa, key)) {
                const a = fa[key];
                if (predicateWithIndex(key, a)) {
                    out[key] = a;
                }
                else {
                    changed = true;
                }
            }
        }
        return changed ? out : fa;
    }
};
const { filter, filterMap, foldMap, partition, partitionMap, reduce, reduceRight, compact, separate } = pipeable(record);
export { 
/**
 * @since 2.0.0
 */
filter, 
/**
 * @since 2.0.0
 */
filterMap, 
/**
 * @since 2.0.0
 */
foldMap, 
/**
 * @since 2.0.0
 */
partition, 
/**
 * @since 2.0.0
 */
partitionMap, 
/**
 * @since 2.0.0
 */
reduce, 
/**
 * @since 2.0.0
 */
reduceRight, 
/**
 * @since 2.0.0
 */
compact, 
/**
 * @since 2.0.0
 */
separate };
