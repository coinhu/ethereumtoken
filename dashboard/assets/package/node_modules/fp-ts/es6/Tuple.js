import { pipeable } from './pipeable';
/**
 * @since 2.0.0
 */
export const URI = 'Tuple';
/**
 * @since 2.0.0
 */
export function fst(sa) {
    return sa[0];
}
/**
 * @since 2.0.0
 */
export function snd(sa) {
    return sa[1];
}
/**
 * @since 2.0.0
 */
export function swap(sa) {
    return [snd(sa), fst(sa)];
}
/**
 * @since 2.0.0
 */
export function getApply(S) {
    return {
        URI,
        _E: undefined,
        map: tuple.map,
        ap: (fab, fa) => [fst(fab)(fst(fa)), S.concat(snd(fab), snd(fa))]
    };
}
const of = (M) => (a) => {
    return [a, M.empty];
};
/**
 * @since 2.0.0
 */
export function getApplicative(M) {
    return Object.assign(Object.assign({}, getApply(M)), { of: of(M) });
}
/**
 * @since 2.0.0
 */
export function getChain(S) {
    return Object.assign(Object.assign({}, getApply(S)), { chain: (fa, f) => {
            const [b, s] = f(fst(fa));
            return [b, S.concat(snd(fa), s)];
        } });
}
/**
 * @since 2.0.0
 */
export function getMonad(M) {
    return Object.assign(Object.assign({}, getChain(M)), { of: of(M) });
}
/**
 * @since 2.0.0
 */
export function getChainRec(M) {
    const chainRec = (a, f) => {
        let result = f(a);
        let acc = M.empty;
        let s = fst(result);
        while (s._tag === 'Left') {
            acc = M.concat(acc, snd(result));
            result = f(s.left);
            s = fst(result);
        }
        return [s.right, M.concat(acc, snd(result))];
    };
    return Object.assign(Object.assign({}, getChain(M)), { chainRec });
}
/**
 * @since 2.0.0
 */
export const tuple = {
    URI,
    compose: (ba, ae) => [fst(ba), snd(ae)],
    map: (ae, f) => [f(fst(ae)), snd(ae)],
    bimap: (fea, f, g) => [g(fst(fea)), f(snd(fea))],
    mapLeft: (fea, f) => [fst(fea), f(snd(fea))],
    extract: fst,
    extend: (ae, f) => [f(ae), snd(ae)],
    reduce: (ae, b, f) => f(b, fst(ae)),
    foldMap: _ => (ae, f) => f(fst(ae)),
    reduceRight: (ae, b, f) => f(fst(ae), b),
    traverse: (F) => (as, f) => {
        return F.map(f(fst(as)), b => [b, snd(as)]);
    },
    sequence: (F) => (fas) => {
        return F.map(fst(fas), a => [a, snd(fas)]);
    }
};
const { bimap, compose, duplicate, extend, foldMap, map, mapLeft, reduce, reduceRight } = pipeable(tuple);
export { 
/**
 * @since 2.0.0
 */
bimap, 
/**
 * @since 2.0.0
 */
compose, 
/**
 * @since 2.0.0
 */
duplicate, 
/**
 * @since 2.0.0
 */
extend, 
/**
 * @since 2.0.0
 */
foldMap, 
/**
 * @since 2.0.0
 */
map, 
/**
 * @since 2.0.0
 */
mapLeft, 
/**
 * @since 2.0.0
 */
reduce, 
/**
 * @since 2.0.0
 */
reduceRight };
