import * as E from './Either';
import { identity as id } from './function';
import { identity } from './Identity';
import { getReaderM } from './ReaderT';
import { pipeable } from './pipeable';
const T = getReaderM(identity);
/**
 * @since 2.0.0
 */
export const URI = 'Reader';
/**
 * Reads the current context
 *
 * @since 2.0.0
 */
export const ask = T.ask;
/**
 * Projects a value from the global context in a Reader
 *
 * @since 2.0.0
 */
export const asks = T.asks;
/**
 * Changes the value of the local context during the execution of the action `ma` (similar to `Contravariant`'s
 * `contramap`).
 *
 * @since 2.0.0
 */
export function local(f) {
    return ma => T.local(ma, f);
}
/**
 * @since 2.0.0
 */
export function getSemigroup(S) {
    return {
        concat: (x, y) => e => S.concat(x(e), y(e))
    };
}
/**
 * @since 2.0.0
 */
export function getMonoid(M) {
    return {
        concat: getSemigroup(M).concat,
        empty: () => M.empty
    };
}
/**
 * @since 2.0.0
 */
export const of = T.of;
/**
 * @since 2.0.0
 */
export const reader = {
    URI,
    map: (ma, f) => e => f(ma(e)),
    of,
    ap: T.ap,
    chain: T.chain,
    promap: (mbc, f, g) => a => g(mbc(f(a))),
    compose: (ab, la) => l => ab(la(l)),
    id: () => id,
    first: pab => ([a, c]) => [pab(a), c],
    second: pbc => ([a, b]) => [a, pbc(b)],
    left: (pab) => E.fold(a => E.left(pab(a)), E.right),
    right: (pbc) => E.fold(E.left, b => E.right(pbc(b)))
};
const { ap, apFirst, apSecond, chain, chainFirst, compose, flatten, map, promap } = pipeable(reader);
export { 
/**
 * @since 2.0.0
 */
ap, 
/**
 * @since 2.0.0
 */
apFirst, 
/**
 * @since 2.0.0
 */
apSecond, 
/**
 * @since 2.0.0
 */
chain, 
/**
 * @since 2.0.0
 */
chainFirst, 
/**
 * @since 2.0.0
 */
compose, 
/**
 * @since 2.0.0
 */
flatten, 
/**
 * @since 2.0.0
 */
map, 
/**
 * @since 2.0.0
 */
promap };
