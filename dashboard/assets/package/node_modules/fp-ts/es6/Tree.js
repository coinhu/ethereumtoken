import { array, empty, getEq as getArrayEq, getMonoid } from './Array';
import { fromEquals } from './Eq';
import { identity } from './function';
import { pipeable } from './pipeable';
/**
 * @since 2.0.0
 */
export const URI = 'Tree';
/**
 * @since 2.0.0
 */
export function make(value, forest = empty) {
    return {
        value,
        forest
    };
}
/**
 * @since 2.0.0
 */
export function getShow(S) {
    const show = (t) => {
        return t.forest === empty || t.forest.length === 0
            ? `make(${S.show(t.value)})`
            : `make(${S.show(t.value)}, [${t.forest.map(show).join(', ')}])`;
    };
    return {
        show
    };
}
/**
 * @since 2.0.0
 */
export function getEq(E) {
    let SA;
    const R = fromEquals((x, y) => E.equals(x.value, y.value) && SA.equals(x.forest, y.forest));
    SA = getArrayEq(R);
    return R;
}
const draw = (indentation, forest) => {
    let r = '';
    const len = forest.length;
    let tree;
    for (let i = 0; i < len; i++) {
        tree = forest[i];
        const isLast = i === len - 1;
        r += indentation + (isLast ? '└' : '├') + '─ ' + tree.value;
        r += draw(indentation + (len > 1 && !isLast ? '│  ' : '   '), tree.forest);
    }
    return r;
};
/**
 * Neat 2-dimensional drawing of a forest
 *
 * @since 2.0.0
 */
export function drawForest(forest) {
    return draw('\n', forest);
}
/**
 * Neat 2-dimensional drawing of a tree
 *
 * @example
 * import { make, drawTree, tree } from 'fp-ts/lib/Tree'
 *
 * const fa = make('a', [
 *   tree.of('b'),
 *   tree.of('c'),
 *   make('d', [tree.of('e'), tree.of('f')])
 * ])
 *
 * assert.strictEqual(drawTree(fa), `a
 * ├─ b
 * ├─ c
 * └─ d
 *    ├─ e
 *    └─ f`)
 *
 *
 * @since 2.0.0
 */
export function drawTree(tree) {
    return tree.value + drawForest(tree.forest);
}
/**
 * Build a tree from a seed value
 *
 * @since 2.0.0
 */
export function unfoldTree(b, f) {
    const [a, bs] = f(b);
    return { value: a, forest: unfoldForest(bs, f) };
}
/**
 * Build a tree from a seed value
 *
 * @since 2.0.0
 */
export function unfoldForest(bs, f) {
    return bs.map(b => unfoldTree(b, f));
}
export function unfoldTreeM(M) {
    const unfoldForestMM = unfoldForestM(M);
    return (b, f) => M.chain(f(b), ([a, bs]) => M.chain(unfoldForestMM(bs, f), ts => M.of({ value: a, forest: ts })));
}
export function unfoldForestM(M) {
    const traverseM = array.traverse(M);
    return (bs, f) => traverseM(bs, b => unfoldTreeM(M)(b, f));
}
/**
 * @since 2.0.0
 */
export function elem(E) {
    const go = (a, fa) => {
        if (E.equals(a, fa.value)) {
            return true;
        }
        return fa.forest.some(tree => go(a, tree));
    };
    return go;
}
/**
 * @since 2.0.0
 */
export const tree = {
    URI,
    map: (fa, f) => ({
        value: f(fa.value),
        forest: fa.forest.map(t => tree.map(t, f))
    }),
    of: a => ({
        value: a,
        forest: empty
    }),
    ap: (fab, fa) => tree.chain(fab, f => tree.map(fa, f)),
    chain: (fa, f) => {
        const { value, forest } = f(fa.value);
        const concat = getMonoid().concat;
        return {
            value,
            forest: concat(forest, fa.forest.map(t => tree.chain(t, f)))
        };
    },
    reduce: (fa, b, f) => {
        let r = f(b, fa.value);
        const len = fa.forest.length;
        for (let i = 0; i < len; i++) {
            r = tree.reduce(fa.forest[i], r, f);
        }
        return r;
    },
    foldMap: M => (fa, f) => tree.reduce(fa, M.empty, (acc, a) => M.concat(acc, f(a))),
    reduceRight: (fa, b, f) => {
        let r = b;
        const len = fa.forest.length;
        for (let i = len - 1; i >= 0; i--) {
            r = tree.reduceRight(fa.forest[i], r, f);
        }
        return f(fa.value, r);
    },
    traverse: (F) => {
        const traverseF = array.traverse(F);
        const r = (ta, f) => F.ap(F.map(f(ta.value), (value) => (forest) => ({
            value,
            forest
        })), traverseF(ta.forest, t => r(t, f)));
        return r;
    },
    sequence: (F) => {
        const traverseF = tree.traverse(F);
        return ta => traverseF(ta, identity);
    },
    extract: wa => wa.value,
    extend: (wa, f) => ({
        value: f(wa),
        forest: wa.forest.map(t => tree.extend(t, f))
    })
};
const { ap, apFirst, apSecond, chain, chainFirst, duplicate, extend, flatten, foldMap, map, reduce, reduceRight } = pipeable(tree);
export { 
/**
 * @since 2.0.0
 */
ap, 
/**
 * @since 2.0.0
 */
apFirst, 
/**
 * @since 2.0.0
 */
apSecond, 
/**
 * @since 2.0.0
 */
chain, 
/**
 * @since 2.0.0
 */
chainFirst, 
/**
 * @since 2.0.0
 */
duplicate, 
/**
 * @since 2.0.0
 */
extend, 
/**
 * @since 2.0.0
 */
flatten, 
/**
 * @since 2.0.0
 */
foldMap, 
/**
 * @since 2.0.0
 */
map, 
/**
 * @since 2.0.0
 */
reduce, 
/**
 * @since 2.0.0
 */
reduceRight };
