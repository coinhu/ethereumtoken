import { identity } from './function';
export function pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij) {
    switch (arguments.length) {
        case 1:
            return a;
        case 2:
            return ab(a);
        case 3:
            return bc(ab(a));
        case 4:
            return cd(bc(ab(a)));
        case 5:
            return de(cd(bc(ab(a))));
        case 6:
            return ef(de(cd(bc(ab(a)))));
        case 7:
            return fg(ef(de(cd(bc(ab(a))))));
        case 8:
            return gh(fg(ef(de(cd(bc(ab(a)))))));
        case 9:
            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
        case 10:
            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));
    }
    return;
}
const isFunctor = (I) => typeof I.map === 'function';
const isContravariant = (I) => typeof I.contramap === 'function';
const isFunctorWithIndex = (I) => typeof I.mapWithIndex === 'function';
const isApply = (I) => typeof I.ap === 'function';
const isChain = (I) => typeof I.chain === 'function';
const isBifunctor = (I) => typeof I.bimap === 'function';
const isExtend = (I) => typeof I.extend === 'function';
const isFoldable = (I) => typeof I.reduce === 'function';
const isFoldableWithIndex = (I) => typeof I.reduceWithIndex === 'function';
const isAlt = (I) => typeof I.alt === 'function';
const isCompactable = (I) => typeof I.compact === 'function';
const isFilterable = (I) => typeof I.filter === 'function';
const isFilterableWithIndex = (I) => typeof I.filterWithIndex === 'function';
const isProfunctor = (I) => typeof I.promap === 'function';
const isSemigroupoid = (I) => typeof I.compose === 'function';
const isMonadThrow = (I) => typeof I.throwError === 'function';
export function pipeable(I) {
    const r = {};
    if (isFunctor(I)) {
        const map = f => fa => I.map(fa, f);
        r.map = map;
    }
    if (isContravariant(I)) {
        const contramap = f => fa => I.contramap(fa, f);
        r.contramap = contramap;
    }
    if (isFunctorWithIndex(I)) {
        const mapWithIndex = f => fa => I.mapWithIndex(fa, f);
        r.mapWithIndex = mapWithIndex;
    }
    if (isApply(I)) {
        const ap = fa => fab => I.ap(fab, fa);
        const apFirst = fb => fa => I.ap(I.map(fa, a => () => a), fb);
        r.ap = ap;
        r.apFirst = apFirst;
        r.apSecond = (fb) => (fa) => I.ap(I.map(fa, () => (b) => b), fb);
    }
    if (isChain(I)) {
        const chain = f => ma => I.chain(ma, f);
        const chainFirst = f => ma => I.chain(ma, a => I.map(f(a), () => a));
        const flatten = mma => I.chain(mma, identity);
        r.chain = chain;
        r.chainFirst = chainFirst;
        r.flatten = flatten;
    }
    if (isBifunctor(I)) {
        const bimap = (f, g) => fa => I.bimap(fa, f, g);
        const mapLeft = f => fa => I.mapLeft(fa, f);
        r.bimap = bimap;
        r.mapLeft = mapLeft;
    }
    if (isExtend(I)) {
        const extend = f => wa => I.extend(wa, f);
        const duplicate = wa => I.extend(wa, identity);
        r.extend = extend;
        r.duplicate = duplicate;
    }
    if (isFoldable(I)) {
        const reduce = (b, f) => fa => I.reduce(fa, b, f);
        const foldMap = M => {
            const foldMapM = I.foldMap(M);
            return f => fa => foldMapM(fa, f);
        };
        const reduceRight = (b, f) => fa => I.reduceRight(fa, b, f);
        r.reduce = reduce;
        r.foldMap = foldMap;
        r.reduceRight = reduceRight;
    }
    if (isFoldableWithIndex(I)) {
        const reduceWithIndex = (b, f) => fa => I.reduceWithIndex(fa, b, f);
        const foldMapWithIndex = M => {
            const foldMapM = I.foldMapWithIndex(M);
            return f => fa => foldMapM(fa, f);
        };
        const reduceRightWithIndex = (b, f) => fa => I.reduceRightWithIndex(fa, b, f);
        r.reduceWithIndex = reduceWithIndex;
        r.foldMapWithIndex = foldMapWithIndex;
        r.reduceRightWithIndex = reduceRightWithIndex;
    }
    if (isAlt(I)) {
        const alt = that => fa => I.alt(fa, that);
        r.alt = alt;
    }
    if (isCompactable(I)) {
        r.compact = I.compact;
        r.separate = I.separate;
    }
    if (isFilterable(I)) {
        const filter = (predicate) => (fa) => I.filter(fa, predicate);
        const filterMap = f => fa => I.filterMap(fa, f);
        const partition = (predicate) => (fa) => I.partition(fa, predicate);
        const partitionMap = f => fa => I.partitionMap(fa, f);
        r.filter = filter;
        r.filterMap = filterMap;
        r.partition = partition;
        r.partitionMap = partitionMap;
    }
    if (isFilterableWithIndex(I)) {
        const filterWithIndex = (predicateWithIndex) => (fa) => I.filterWithIndex(fa, predicateWithIndex);
        const filterMapWithIndex = f => fa => I.filterMapWithIndex(fa, f);
        const partitionWithIndex = (predicateWithIndex) => (fa) => I.partitionWithIndex(fa, predicateWithIndex);
        const partitionMapWithIndex = f => fa => I.partitionMapWithIndex(fa, f);
        r.filterWithIndex = filterWithIndex;
        r.filterMapWithIndex = filterMapWithIndex;
        r.partitionWithIndex = partitionWithIndex;
        r.partitionMapWithIndex = partitionMapWithIndex;
    }
    if (isProfunctor(I)) {
        const promap = (f, g) => fa => I.promap(fa, f, g);
        r.promap = promap;
    }
    if (isSemigroupoid(I)) {
        const compose = that => fa => I.compose(fa, that);
        r.compose = compose;
    }
    if (isMonadThrow(I)) {
        const fromOption = onNone => ma => ma._tag === 'None' ? I.throwError(onNone()) : I.of(ma.value);
        const fromEither = ma => ma._tag === 'Left' ? I.throwError(ma.left) : I.of(ma.right);
        const fromPredicate = (predicate, onFalse) => (a) => (predicate(a) ? I.of(a) : I.throwError(onFalse(a)));
        const filterOrElse = (predicate, onFalse) => (ma) => I.chain(ma, a => (predicate(a) ? I.of(a) : I.throwError(onFalse(a))));
        r.fromOption = fromOption;
        r.fromEither = fromEither;
        r.fromPredicate = fromPredicate;
        r.filterOrElse = filterOrElse;
    }
    return r;
}
