import { fromEquals } from './Eq';
import { not, identity } from './function';
/**
 * @since 2.0.0
 */
export function getShow(S) {
    return {
        show: s => {
            let elements = '';
            s.forEach(a => {
                elements += S.show(a) + ', ';
            });
            if (elements !== '') {
                elements = elements.substring(0, elements.length - 2);
            }
            return `new Set([${elements}])`;
        }
    };
}
/**
 * @since 2.0.0
 */
export const empty = new Set();
/**
 * @since 2.0.0
 */
export function toArray(O) {
    return x => {
        const r = [];
        x.forEach(e => r.push(e));
        return r.sort(O.compare);
    };
}
/**
 * @since 2.0.0
 */
export function getEq(E) {
    const subsetE = subset(E);
    return fromEquals((x, y) => subsetE(x, y) && subsetE(y, x));
}
/**
 * @since 2.0.0
 */
export function some(predicate) {
    return set => {
        const values = set.values();
        let e;
        let found = false;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!found && !(e = values.next()).done) {
            found = predicate(e.value);
        }
        return found;
    };
}
/**
 * Projects a Set through a function
 *
 * @since 2.0.0
 */
export function map(E) {
    const elemE = elem(E);
    return f => set => {
        const r = new Set();
        set.forEach(e => {
            const v = f(e);
            if (!elemE(v, r)) {
                r.add(v);
            }
        });
        return r;
    };
}
/**
 * @since 2.0.0
 */
export function every(predicate) {
    return not(some(not(predicate)));
}
/**
 * @since 2.0.0
 */
export function chain(E) {
    const elemE = elem(E);
    return f => set => {
        const r = new Set();
        set.forEach(e => {
            f(e).forEach(e => {
                if (!elemE(e, r)) {
                    r.add(e);
                }
            });
        });
        return r;
    };
}
/**
 * `true` if and only if every element in the first set is an element of the second set
 *
 * @since 2.0.0
 */
export function subset(E) {
    const elemE = elem(E);
    return (x, y) => every((a) => elemE(a, y))(x);
}
export function filter(predicate) {
    return set => {
        const values = set.values();
        let e;
        const r = new Set();
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = values.next()).done) {
            const value = e.value;
            if (predicate(value)) {
                r.add(value);
            }
        }
        return r;
    };
}
export function partition(predicate) {
    return set => {
        const values = set.values();
        let e;
        const right = new Set();
        const left = new Set();
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = values.next()).done) {
            const value = e.value;
            if (predicate(value)) {
                right.add(value);
            }
            else {
                left.add(value);
            }
        }
        return { left, right };
    };
}
/**
 * Test if a value is a member of a set
 *
 * @since 2.0.0
 */
export function elem(E) {
    return (a, set) => {
        const values = set.values();
        let e;
        let found = false;
        // tslint:disable-next-line: strict-boolean-expressions
        while (!found && !(e = values.next()).done) {
            found = E.equals(a, e.value);
        }
        return found;
    };
}
/**
 * Form the union of two sets
 *
 * @since 2.0.0
 */
export function union(E) {
    const elemE = elem(E);
    return (x, y) => {
        if (x === empty) {
            return y;
        }
        if (y === empty) {
            return x;
        }
        const r = new Set(x);
        y.forEach(e => {
            if (!elemE(e, r)) {
                r.add(e);
            }
        });
        return r;
    };
}
/**
 * The set of elements which are in both the first and second set
 *
 * @since 2.0.0
 */
export function intersection(E) {
    const elemE = elem(E);
    return (x, y) => {
        if (x === empty || y === empty) {
            return empty;
        }
        const r = new Set();
        x.forEach(e => {
            if (elemE(e, y)) {
                r.add(e);
            }
        });
        return r;
    };
}
/**
 * @since 2.0.0
 */
export function partitionMap(EB, EC) {
    return (f) => (set) => {
        const values = set.values();
        let e;
        const left = new Set();
        const right = new Set();
        const hasB = elem(EB);
        const hasC = elem(EC);
        // tslint:disable-next-line: strict-boolean-expressions
        while (!(e = values.next()).done) {
            const v = f(e.value);
            switch (v._tag) {
                case 'Left':
                    if (!hasB(v.left, left)) {
                        left.add(v.left);
                    }
                    break;
                case 'Right':
                    if (!hasC(v.right, right)) {
                        right.add(v.right);
                    }
                    break;
            }
        }
        return { left, right };
    };
}
/**
 * Form the set difference (`x` - `y`)
 *
 * @example
 * import { difference } from 'fp-ts/lib/Set'
 * import { eqNumber } from 'fp-ts/lib/Eq'
 *
 * assert.deepStrictEqual(difference(eqNumber)(new Set([1, 2]), new Set([1, 3])), new Set([2]))
 *
 *
 * @since 2.0.0
 */
export function difference(E) {
    const elemE = elem(E);
    return (x, y) => filter((a) => !elemE(a, y))(x);
}
/**
 * @since 2.0.0
 */
export function getUnionMonoid(E) {
    return {
        concat: union(E),
        empty
    };
}
/**
 * @since 2.0.0
 */
export function getIntersectionSemigroup(E) {
    return {
        concat: intersection(E)
    };
}
/**
 * @since 2.0.0
 */
export function reduce(O) {
    const toArrayO = toArray(O);
    return (b, f) => fa => toArrayO(fa).reduce(f, b);
}
/**
 * @since 2.0.0
 */
export function foldMap(O, M) {
    const toArrayO = toArray(O);
    return f => fa => toArrayO(fa).reduce((b, a) => M.concat(b, f(a)), M.empty);
}
/**
 * Create a set with one element
 *
 * @since 2.0.0
 */
export function singleton(a) {
    return new Set([a]);
}
/**
 * Insert a value into a set
 *
 * @since 2.0.0
 */
export function insert(E) {
    const elemE = elem(E);
    return a => set => {
        if (!elemE(a, set)) {
            const r = new Set(set);
            r.add(a);
            return r;
        }
        else {
            return set;
        }
    };
}
/**
 * Delete a value from a set
 *
 * @since 2.0.0
 */
export function remove(E) {
    return a => set => filter((ax) => !E.equals(a, ax))(set);
}
/**
 * Create a set from an array
 *
 * @since 2.0.0
 */
export function fromArray(E) {
    return as => {
        const len = as.length;
        const r = new Set();
        const has = elem(E);
        for (let i = 0; i < len; i++) {
            const a = as[i];
            if (!has(a, r)) {
                r.add(a);
            }
        }
        return r;
    };
}
/**
 * @since 2.0.0
 */
export function compact(E) {
    return filterMap(E)(identity);
}
/**
 * @since 2.0.0
 */
export function separate(EE, EA) {
    return fa => {
        const elemEE = elem(EE);
        const elemEA = elem(EA);
        const left = new Set();
        const right = new Set();
        fa.forEach(e => {
            switch (e._tag) {
                case 'Left':
                    if (!elemEE(e.left, left)) {
                        left.add(e.left);
                    }
                    break;
                case 'Right':
                    if (!elemEA(e.right, right)) {
                        right.add(e.right);
                    }
                    break;
            }
        });
        return { left, right };
    };
}
/**
 * @since 2.0.0
 */
export function filterMap(E) {
    const elemE = elem(E);
    return f => fa => {
        const r = new Set();
        fa.forEach(a => {
            const ob = f(a);
            if (ob._tag === 'Some' && !elemE(ob.value, r)) {
                r.add(ob.value);
            }
        });
        return r;
    };
}
