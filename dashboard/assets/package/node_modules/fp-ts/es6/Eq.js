import { pipeable } from './pipeable';
/**
 * @since 2.0.0
 */
export const URI = 'Eq';
/**
 * @since 2.0.0
 */
export function fromEquals(equals) {
    return {
        equals: (x, y) => x === y || equals(x, y)
    };
}
/**
 * @since 2.0.0
 */
export function strictEqual(a, b) {
    return a === b;
}
const eqStrict = { equals: strictEqual };
/**
 * @since 2.0.0
 */
export const eqString = eqStrict;
/**
 * @since 2.0.0
 */
export const eqNumber = eqStrict;
/**
 * @since 2.0.0
 */
export const eqBoolean = eqStrict;
/**
 * @since 2.0.0
 */
export function getStructEq(eqs) {
    return fromEquals((x, y) => {
        for (const k in eqs) {
            if (!eqs[k].equals(x[k], y[k])) {
                return false;
            }
        }
        return true;
    });
}
/**
 * Given a tuple of `Eq`s returns a `Eq` for the tuple
 *
 * @example
 * import { getTupleEq, eqString, eqNumber, eqBoolean } from 'fp-ts/lib/Eq'
 *
 * const E = getTupleEq(eqString, eqNumber, eqBoolean)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, true]), true)
 * assert.strictEqual(E.equals(['a', 1, true], ['b', 1, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 2, true]), false)
 * assert.strictEqual(E.equals(['a', 1, true], ['a', 1, false]), false)
 *
 * @since 2.0.0
 */
export function getTupleEq(...eqs) {
    return fromEquals((x, y) => eqs.every((E, i) => E.equals(x[i], y[i])));
}
/**
 * @since 2.0.0
 */
export const eq = {
    URI,
    contramap: (fa, f) => fromEquals((x, y) => fa.equals(f(x), f(y)))
};
const { contramap } = pipeable(eq);
export { 
/**
 * @since 2.0.0
 */
contramap };
/**
 * @since 2.0.0
 */
export const eqDate = eq.contramap(eqNumber, date => date.valueOf());
