"use strict";

exports.__esModule = true;
exports.getMembersFromNode = getMembersFromNode;
exports.stripDetailsFromTree = exports.parseNameFromNode = void 0;

var ts = _interopRequireWildcard(require("typescript"));

var _util = _interopRequireDefault(require("util"));

var logger = _interopRequireWildcard(require("../logger"));

var _lodash = _interopRequireDefault(require("lodash"));

var _nodename = _interopRequireDefault(require("../nodename"));

var _printers = _interopRequireDefault(require("../printers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const inspect = Symbol.for("nodejs.util.inspect.custom");

const parseNameFromNode = node => {
  if (node.name && node.name.text) {
    return node.name.text;
  } else if (node.type && node.type.typeName) {
    return node.type.typeName.text;
  } else if (node.exportClause) {
    let names = [];
    ts.forEachChild(node.exportClause, child => {
      names.push(parseNameFromNode(child));
    });
    return names.join(",");
  } else if (node.importClause && node.importClause.namedBindings) {
    return parseNameFromNode(node.importClause.namedBindings);
  } else if (node.moduleSpecifier) {
    return node.moduleSpecifier.text;
  } else if (node.expression) {
    return _printers.default.node.printType(stripDetailsFromTree(node.expression));
  } else if (node.declarationList) {
    const declarations = node.declarationList.declarations.map(stripDetailsFromTree).map(_printers.default.node.printType).join(" ");
    return declarations;
  } else if (node.kind === ts.SyntaxKind.NamedImports) {
    let names = [];
    ts.forEachChild(node, child => {
      names.push(parseNameFromNode(child));
    });
    return names.join(",");
  }

  switch (node.kind) {
    case ts.SyntaxKind.FunctionDeclaration:
      logger.error(node.modifiers || node, {
        type: "MissingFunctionName"
      });
      break;

    default:
      console.log("INVALID NAME", ts.SyntaxKind[node.kind]);
      break;
  }

  return "INVALID NAME REF";
};

exports.parseNameFromNode = parseNameFromNode;

function inspectFn(depth, options) {
  const newOptions = Object.assign({}, options, {
    depth: options.depth == null ? null : options.depth - 1
  });

  if (depth < 0) {
    const _this = this,
          rest = _objectWithoutPropertiesLoose(_this, ["parent", "symbol", "localSymbol"]);

    delete rest[inspect];

    if (rest.kind) {
      return `${ts.SyntaxKind[rest.kind]} ${_util.default.inspect(rest, newOptions)}`;
    } else {
      return _util.default.inspect(rest, newOptions);
    }
  }

  const _this2 = this,
        rest = _objectWithoutPropertiesLoose(_this2, ["parent", "symbol", "localSymbol"]);

  for (const key in rest) {
    if (rest.hasOwnProperty(key) && typeof rest[key] === "object") {
      rest[key][inspect] = inspectFn.bind(rest[key]);
    }
  }

  delete rest[inspect];

  if (rest.kind) {
    return `${ts.SyntaxKind[rest.kind]} ${_util.default.inspect(rest, newOptions)}`;
  } else {
    return _util.default.inspect(rest, newOptions);
  }
} // Traverse a node and strip information we dont care about
// This is mostly to make debugging a bit less verbose


const stripDetailsFromTree = root => {
  for (const key in root) {
    const val = root[key];
    if (key === "parent") continue;
    if (key === "symbol") continue;
    if (key === "localSymbol") continue;
    if (typeof val === "function") continue;
    if (typeof val !== "object") continue;

    if (root.hasOwnProperty(key) && typeof val === "object") {
      if (Array.isArray(val)) {
        root[key] = root[key].map(stripDetailsFromTree);
        root[key].pos = val.pos;
        root[key].end = val.end;
        root[key].assertHasRealPosition = root.assertHasRealPosition.bind(val);
        root[key].getStart = root.getStart.bind(val);
        root[key].getEnd = root.getEnd.bind(val);
      } else {
        root[key][inspect] = inspectFn.bind(val);
      }
    }
  }

  root[inspect] = inspectFn.bind(root);
  return root;
};

exports.stripDetailsFromTree = stripDetailsFromTree;

function getMembersFromNode(node) {
  if (node.members) {
    return node.members;
  }

  if (node.type && node.type.members) {
    return node.type.members;
  }

  console.log("NO MEMBERS_", ts.SyntaxKind[node.kind], node);
}